#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "../include/precision.glsl"

/**
 * @file computeFieldStrengths.comp
 * @brief Compute electromagnetic field strengths E, B from gauge potentials
 *
 * Physics:
 * --------
 * Electric field: E = -∇φ - ∂_t A
 * Magnetic field: B = ∇ × A
 *
 * In 2D (quasi-static approximation):
 * E_x = -∂_x φ - ∂_t A_x  (∂_t A ≈ 0 for quasi-static → E_x = -∂_x φ)
 * E_y = -∂_y φ - ∂_t A_y  (similarly, E_y = -∂_y φ)
 * B_z = ∂_x A_y - ∂_y A_x (curl of A in 2D, only z-component)
 *
 * Quasi-static assumption: Valid when phase evolution is slow compared to
 * light speed (∂_t θ << c·∇θ). This holds for Kuramoto oscillators with
 * ω_i ~ O(1), K ~ O(1) in natural units.
 *
 * Numerical Method:
 * -----------------
 * - Spatial derivatives: Centered finite difference (2nd order accurate)
 * - Boundary conditions: Periodic
 *
 * Workgroup: 16×16 threads
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Descriptor set 0: Field strength computation
layout(set = 0, binding = 0) readonly buffer Phi {
    float phi[];  // φ = ∂_t θ (scalar potential)
};

layout(set = 0, binding = 1) readonly buffer A_x {
    float A_x_in[];  // A_x = ∂_x θ
};

layout(set = 0, binding = 2) readonly buffer A_y {
    float A_y_in[];  // A_y = ∂_y θ
};

layout(set = 0, binding = 3) writeonly buffer E_x {
    float E_x_out[];  // E_x = -∂_x φ
};

layout(set = 0, binding = 4) writeonly buffer E_y {
    float E_y_out[];  // E_y = -∂_y φ
};

layout(set = 0, binding = 5) writeonly buffer B_z {
    float B_z_out[];  // B_z = ∂_x A_y - ∂_y A_x
};

layout(set = 0, binding = 6) uniform Params {
    uint Nx;       // Grid width
    uint Ny;       // Grid height
    float dx;      // Spatial step size
    float dy;      // Spatial step size
} params;

void main() {
    uint i = gl_GlobalInvocationID.x;
    uint j = gl_GlobalInvocationID.y;

    // Bounds check
    if (i >= params.Nx || j >= params.Ny) {
        return;
    }

    uint idx = j * params.Nx + i;

    // ========================================================================
    // SPATIAL DERIVATIVES (PERIODIC BOUNDARY CONDITIONS)
    // ========================================================================

    // Neighbors in x-direction
    uint i_left = (i == 0) ? (params.Nx - 1) : (i - 1);
    uint i_right = (i == params.Nx - 1) ? 0 : (i + 1);
    uint idx_left = j * params.Nx + i_left;
    uint idx_right = j * params.Nx + i_right;

    // Neighbors in y-direction
    uint j_down = (j == 0) ? (params.Ny - 1) : (j - 1);
    uint j_up = (j == params.Ny - 1) ? 0 : (j + 1);
    uint idx_down = j_down * params.Nx + i;
    uint idx_up = j_up * params.Nx + i;

    // ========================================================================
    // ELECTRIC FIELD: E = -∇φ
    // ========================================================================
    // E_x = -∂_x φ
    float dPhi_dx = (phi[idx_right] - phi[idx_left]) / (2.0 * params.dx);
    float E_x_val = -dPhi_dx;

    // E_y = -∂_y φ
    float dPhi_dy = (phi[idx_up] - phi[idx_down]) / (2.0 * params.dy);
    float E_y_val = -dPhi_dy;

    // ========================================================================
    // MAGNETIC FIELD: B = ∇ × A
    // ========================================================================
    // B_z = ∂_x A_y - ∂_y A_x (2D curl, only z-component)
    float dAy_dx = (A_y_in[idx_right] - A_y_in[idx_left]) / (2.0 * params.dx);
    float dAx_dy = (A_x_in[idx_up] - A_x_in[idx_down]) / (2.0 * params.dy);
    float B_z_val = dAy_dx - dAx_dy;

    // ========================================================================
    // OUTPUT
    // ========================================================================
    E_x_out[idx] = E_x_val;
    E_y_out[idx] = E_y_val;
    B_z_out[idx] = B_z_val;
}
