#version 450
#extension GL_ARB_separate_shader_objects : enable

// Simplified precision - use float32 with basic arithmetic
#define highp_float float

/**
 * Fixed sync_field shader with proper shared memory corner loading
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    float dt;
    float K;
    float damping;
    float Delta;
    float chiral_angle;
    float Nx;
    float Ny;
    float N_total;
    float neighborhood_radius;
} params;

layout(set = 0, binding = 0) readonly buffer ThetaBuffer {
    float theta[];
};

layout(set = 0, binding = 1) buffer RFieldBuffer {
    float R_field[];
};

shared float s_theta[18][18];

void load_shared_memory(uvec2 global_id, uvec2 local_id) {
    uint gx = global_id.x;
    uint gy = global_id.y;
    uint lx = local_id.x;
    uint ly = local_id.y;
    uint Nx = uint(params.Nx);
    uint Ny = uint(params.Ny);

    // Load center tile
    if (gx < Nx && gy < Ny) {
        uint idx = gy * Nx + gx;
        s_theta[ly + 1][lx + 1] = theta[idx];
    }

    // Load borders with periodic wrapping
    // Left border
    if (lx == 0) {
        uint border_x = (gx == 0) ? (Nx - 1) : (gx - 1);
        if (gy < Ny) {
            s_theta[ly + 1][0] = theta[gy * Nx + border_x];
        }
    }

    // Right border
    if (lx == 15) {
        uint border_x = (gx == Nx - 1) ? 0 : (gx + 1);
        if (gy < Ny) {
            s_theta[ly + 1][17] = theta[gy * Nx + border_x];
        }
    }

    // Top border
    if (ly == 0) {
        uint border_y = (gy == 0) ? (Ny - 1) : (gy - 1);
        if (gx < Nx) {
            s_theta[0][lx + 1] = theta[border_y * Nx + gx];
        }
    }

    // Bottom border
    if (ly == 15) {
        uint border_y = (gy == Ny - 1) ? 0 : (gy + 1);
        if (gx < Nx) {
            s_theta[17][lx + 1] = theta[border_y * Nx + gx];
        }
    }

    // FIX: Load corner cells
    if (lx == 0 && ly == 0) {
        // Top-left corner
        uint cx = (gx == 0) ? (Nx - 1) : (gx - 1);
        uint cy = (gy == 0) ? (Ny - 1) : (gy - 1);
        s_theta[0][0] = theta[cy * Nx + cx];
    }

    if (lx == 15 && ly == 0) {
        // Top-right corner
        uint cx = (gx == Nx - 1) ? 0 : (gx + 1);
        uint cy = (gy == 0) ? (Ny - 1) : (gy - 1);
        s_theta[0][17] = theta[cy * Nx + cx];
    }

    if (lx == 0 && ly == 15) {
        // Bottom-left corner
        uint cx = (gx == 0) ? (Nx - 1) : (gx - 1);
        uint cy = (gy == Ny - 1) ? 0 : (gy + 1);
        s_theta[17][0] = theta[cy * Nx + cx];
    }

    if (lx == 15 && ly == 15) {
        // Bottom-right corner
        uint cx = (gx == Nx - 1) ? 0 : (gx + 1);
        uint cy = (gy == Ny - 1) ? 0 : (gy + 1);
        s_theta[17][17] = theta[cy * Nx + cx];
    }

    barrier();  // Now safe - all cells initialized
}

float compute_local_R(uint local_x, uint local_y) {
    float sum_cos = 0.0;
    float sum_sin = 0.0;
    int count = 0;

    // 3x3 neighborhood (radius=1)
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            uint nx = local_x + 1 + uint(dx);
            uint ny = local_y + 1 + uint(dy);

            float theta_j = s_theta[ny][nx];

            // e^(iθ) = cos(θ) + i·sin(θ)
            sum_cos += cos(theta_j);
            sum_sin += sin(theta_j);
            count++;
        }
    }

    // R = |⟨e^(iθ)⟩|
    float avg_cos = sum_cos / float(count);
    float avg_sin = sum_sin / float(count);
    float R = sqrt(avg_cos * avg_cos + avg_sin * avg_sin);

    return clamp(R, 0.0, 1.0);
}

void main() {
    uvec2 global_id = gl_GlobalInvocationID.xy;
    uvec2 local_id = gl_LocalInvocationID.xy;

    if (global_id.x >= uint(params.Nx) || global_id.y >= uint(params.Ny)) {
        return;
    }

    uint idx = global_id.y * uint(params.Nx) + global_id.x;

    load_shared_memory(global_id, local_id);

    float R_local = compute_local_R(local_id.x, local_id.y);

    R_field[idx] = R_local;
}
