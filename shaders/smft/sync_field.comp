#version 450
#extension GL_ARB_separate_shader_objects : enable

// Include complex arithmetic and precision libraries
#include "../include/complex.glsl"
#include "../include/precision.glsl"

/**
 * @file sync_field.comp
 * @brief Compute local synchronization field R(x,y) from Kuramoto phases
 *
 * Implements: R(x,y) = |⟨e^(iθ)⟩_local| = |Σⱼ e^(iθⱼ)|/N_local
 *
 * MSFT Forward Coupling:
 * - Input: θ(x,y) phase field from Kuramoto oscillators
 * - Output: R(x,y) synchronization order parameter
 * - Physics: R = 0 (incoherent), R = 1 (perfect sync)
 *
 * Spatial Structure:
 * - Local averaging over neighborhood (supports soliton formation)
 * - Preserves spatial structure of synchronization
 *
 * Workgroup: 16×16 threads
 * Grid: Nx × Ny spatial points
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Push constants for simulation parameters
layout(push_constant) uniform PushConstants {
    float dt;              // Time step (not used here, but kept for consistency)
    float K;               // Coupling strength (not used here)
    float damping;         // Damping (not used here)
    float Delta;           // MSFT mass gap (not used here)
    float chiral_angle;    // Chiral angle (not used here)
    uint Nx;               // Grid width
    uint Ny;               // Grid height
    uint N_total;          // Total oscillators
    uint neighborhood_radius;  // Radius for local averaging (typically 1-3)
} params;

// Storage buffers
layout(set = 0, binding = 0) readonly buffer ThetaBuffer {
    float theta[];  // Current phases from kuramoto_step.comp
};

layout(set = 0, binding = 1) buffer RFieldBuffer {
    float R_field[];  // Output: synchronization field R(x,y)
};

// Shared memory for local computation
shared float s_theta[18][18];  // 16+2 border for neighbors

/**
 * @brief Load theta values into shared memory with boundary handling
 */
void load_shared_memory(uvec2 global_id, uvec2 local_id) {
    uint gx = global_id.x;
    uint gy = global_id.y;
    uint lx = local_id.x;
    uint ly = local_id.y;

    // Load center tile
    if (gx < params.Nx && gy < params.Ny) {
        uint idx = gy * params.Nx + gx;
        s_theta[ly + 1][lx + 1] = theta[idx];
    }

    // Load borders (with wrapping for periodic boundaries)
    // Left border
    if (lx == 0) {
        uint border_x = (gx == 0) ? (params.Nx - 1) : (gx - 1);
        if (gy < params.Ny) {
            uint idx = gy * params.Nx + border_x;
            s_theta[ly + 1][0] = theta[idx];
        }
    }

    // Right border
    if (lx == 15) {
        uint border_x = (gx == params.Nx - 1) ? 0 : (gx + 1);
        if (gy < params.Ny) {
            uint idx = gy * params.Nx + border_x;
            s_theta[ly + 1][17] = theta[idx];
        }
    }

    // Top border
    if (ly == 0) {
        uint border_y = (gy == 0) ? (params.Ny - 1) : (gy - 1);
        if (gx < params.Nx) {
            uint idx = border_y * params.Nx + gx;
            s_theta[0][lx + 1] = theta[idx];
        }
    }

    // Bottom border
    if (ly == 15) {
        uint border_y = (gy == params.Ny - 1) ? 0 : (gy + 1);
        if (gx < params.Nx) {
            uint idx = border_y * params.Nx + gx;
            s_theta[17][lx + 1] = theta[idx];
        }
    }

    barrier();  // Wait for all threads to finish loading
}

/**
 * @brief Compute local synchronization order parameter R(x,y)
 *
 * Formula: R·e^(iΦ) = (1/N) Σⱼ e^(iθⱼ)
 *
 * We compute: R = |Σⱼ e^(iθⱼ)|/N
 *
 * Using Kahan summation for precision (Hazard B mitigation)
 */
float compute_local_R(uint local_x, uint local_y) {
    // Kahan summation for real and imaginary parts
    KahanSum sum_real = kahan_init();
    KahanSum sum_imag = kahan_init();

    uint neighbor_count = 0;

    // Sum over neighborhood (Moore neighborhood by default, radius=1)
    int radius = int(params.neighborhood_radius);

    for (int dy = -radius; dy <= radius; dy++) {
        for (int dx = -radius; dx <= radius; dx++) {
            uint nx = local_x + 1 + dx;
            uint ny = local_y + 1 + dy;

            // Get phase from shared memory
            float theta_j = s_theta[ny][nx];

            // e^(iθⱼ) = cos(θⱼ) + i·sin(θⱼ)
            complex phase_vector = cexp_i(theta_j);

            // Accumulate with Kahan summation
            kahan_add(sum_real, highp_float(phase_vector.x));
            kahan_add(sum_imag, highp_float(phase_vector.y));

            neighbor_count++;
        }
    }

    // Compute average: ⟨e^(iθ)⟩ = Σe^(iθⱼ) / N
    complex avg_phase = vec2(
        float(kahan_result(sum_real)) / float(neighbor_count),
        float(kahan_result(sum_imag)) / float(neighbor_count)
    );

    // R = |⟨e^(iθ)⟩|
    float R = cabs(avg_phase);

    return R;
}

/**
 * @brief Compute global synchronization order parameter (alternative)
 *
 * For comparison/debugging: R_global = |Σⱼ e^(iθⱼ)|/N_total
 *
 * This is NOT used in MSFT (we use local R), but useful for diagnostics
 */
float compute_global_R_contribution(float theta_i) {
    // This would require a reduction across all threads
    // For now, we return the local contribution
    // Actual global R would need atomic operations or a separate reduction pass
    return 1.0;  // Placeholder
}

void main() {
    uvec2 global_id = gl_GlobalInvocationID.xy;
    uvec2 local_id = gl_LocalInvocationID.xy;

    // Bounds check
    if (global_id.x >= params.Nx || global_id.y >= params.Ny) {
        return;
    }

    uint idx = global_id.y * params.Nx + global_id.x;

    // Load theta values into shared memory
    load_shared_memory(global_id, local_id);

    // Compute local synchronization order parameter
    float R_local = compute_local_R(local_id.x, local_id.y);

    // Clamp to physical range [0, 1]
    R_local = clamp(R_local, 0.0, 1.0);

    // Write output
    R_field[idx] = R_local;
}
