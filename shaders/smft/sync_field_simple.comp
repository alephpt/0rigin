#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    float dt;
    float K;
    float damping;
    float Delta;
    float chiral_angle;
    float Nx;
    float Ny;
    float N_total;
    float neighborhood_radius;
} params;

layout(set = 0, binding = 0) readonly buffer ThetaBuffer {
    float theta[];
};

layout(set = 0, binding = 1) buffer RFieldBuffer {
    float R_field[];
};

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;

    if (gid.x >= uint(params.Nx) || gid.y >= uint(params.Ny)) {
        return;
    }

    uint idx = gid.y * uint(params.Nx) + gid.x;

    // Simple local R calculation without shared memory
    float sum_cos = 0.0;
    float sum_sin = 0.0;
    int count = 0;

    // 3x3 neighborhood
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            int nx = int(gid.x) + dx;
            int ny = int(gid.y) + dy;

            // Periodic boundaries
            if (nx < 0) nx += int(params.Nx);
            if (nx >= int(params.Nx)) nx -= int(params.Nx);
            if (ny < 0) ny += int(params.Ny);
            if (ny >= int(params.Ny)) ny -= int(params.Ny);

            uint nidx = uint(ny) * uint(params.Nx) + uint(nx);
            float theta_j = theta[nidx];

            sum_cos += cos(theta_j);
            sum_sin += sin(theta_j);
            count++;
        }
    }

    float avg_cos = sum_cos / float(count);
    float avg_sin = sum_sin / float(count);
    float R = sqrt(avg_cos * avg_cos + avg_sin * avg_sin);

    R_field[idx] = clamp(R, 0.0, 1.0);
}
