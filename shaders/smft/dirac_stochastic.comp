#version 450
#extension GL_ARB_separate_shader_objects : enable

// Include complex arithmetic and precision libraries
#include "../include/complex.glsl"
#include "../include/precision.glsl"

/**
 * @file dirac_stochastic.comp
 * @brief Stochastic Dirac evolution with MSR noise formalism
 *
 * Implements: i∂_tΨ = H_DiracΨ + σ_Ψ·√(dt)·ξ(t)
 *
 * where:
 * - H_Dirac = -i·α·∇ + β·M(x,t)
 * - M(x,t) = Δ·R(x,t) (mass from synchronization field)
 * - ξ(t) = Complex Gaussian white noise
 * - σ_Ψ = Spinor noise amplitude (baseline: 0.05)
 *
 * Uses Euler-Maruyama integration with proper √(dt) scaling
 *
 * Spinor layout: Ψ = (ψ₁, ψ₂, ψ₃, ψ₄) where ψᵢ ∈ ℂ
 * Storage: vec2 array with [real, imag] for each component
 *
 * PRNG: PCG (same as kuramoto_stochastic.comp)
 * Gaussian: Box-Muller transform for complex noise
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Push constants for simulation parameters
layout(push_constant) uniform PushConstants {
    float dt;              // Time step (0.01)
    float K;               // Kuramoto coupling (not used here)
    float sigma_psi;       // Spinor noise amplitude (0.05 baseline)
    float damping;         // Damping (not used)
    float Delta;           // Mass gap parameter (2.5)
    uint Nx;               // Grid width
    uint Ny;               // Grid height
    uint time_step;        // Current timestep for PRNG
} params;

// Storage buffers
layout(set = 0, binding = 0) buffer PsiBuffer {
    vec2 psi[];  // Current spinor field (4 components × vec2 per point)
};

layout(set = 0, binding = 1) readonly buffer RFieldBuffer {
    float R_field[];  // Synchronization field magnitude |R(x,y)|
};

// Shared memory for spatial derivatives
shared vec2 s_psi[18][18][4];  // 16+2 border, 4 spinor components

// ============================================================================
// PCG Random Number Generator (identical to kuramoto_stochastic.comp)
// ============================================================================

uint pcg_state;

uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

void pcg_init(uint seed) {
    pcg_state = pcg_hash(seed);
}

float pcg_random() {
    pcg_state = pcg_state * 747796405u + 2891336453u;
    uint word = ((pcg_state >> ((pcg_state >> 28u) + 4u)) ^ pcg_state) * 277803737u;
    word = (word >> 22u) ^ word;
    return float(word) / 4294967296.0;
}

// ============================================================================
// Complex Gaussian Noise Generation
// ============================================================================

/**
 * @brief Generate standard normal N(0,1) using Box-Muller
 */
float randn() {
    float u1 = pcg_random();
    float u2 = pcg_random();

    // Avoid log(0)
    u1 = max(u1, 1e-10);

    const float PI = 3.14159265359;
    float r = sqrt(-2.0 * log(u1));
    float theta = 2.0 * PI * u2;

    return r * cos(theta);
}

/**
 * @brief Generate complex Gaussian noise
 * Returns vec2(real, imag) both drawn from N(0,1)
 */
vec2 complex_randn() {
    float u1 = pcg_random();
    float u2 = pcg_random();

    u1 = max(u1, 1e-10);

    const float PI = 3.14159265359;
    float r = sqrt(-2.0 * log(u1));
    float theta = 2.0 * PI * u2;

    // Return both values from Box-Muller transform
    return vec2(r * cos(theta), r * sin(theta));
}

// ============================================================================
// Dirac Matrix Operations (2D simplified version)
// ============================================================================

/**
 * @brief Apply α^x (spatial derivative in x direction)
 *
 * In 2D chiral representation:
 * α^x = γ^0·γ^1 = [[σ^x  0  ],    where σ^x = [[0 1],
 *                   [ 0  -σ^x]]                  [1 0]]
 */
void apply_alpha_x(vec2 psi_in[4], out vec2 psi_out[4]) {
    psi_out[0] = psi_in[1];
    psi_out[1] = psi_in[0];
    psi_out[2] = -psi_in[3];
    psi_out[3] = -psi_in[2];
}

/**
 * @brief Apply α^y (spatial derivative in y direction)
 *
 * α^y = γ^0·γ^2 = [[σ^y  0  ],    where σ^y = [[0 -i],
 *                   [ 0  -σ^y]]                  [i  0]]
 */
void apply_alpha_y(vec2 psi_in[4], out vec2 psi_out[4]) {
    psi_out[0] = cmul(vec2(0, -1), psi_in[1]);  // -i·ψ₂
    psi_out[1] = cmul(vec2(0, 1), psi_in[0]);   // i·ψ₁
    psi_out[2] = cmul(vec2(0, 1), psi_in[3]);   // i·ψ₄
    psi_out[3] = cmul(vec2(0, -1), psi_in[2]);  // -i·ψ₃
}

/**
 * @brief Apply β matrix (mass term)
 *
 * β = γ^0 = [[ 0  I],
 *            [-I  0]]
 */
void apply_beta(vec2 psi_in[4], out vec2 psi_out[4]) {
    psi_out[0] = psi_in[2];
    psi_out[1] = psi_in[3];
    psi_out[2] = -psi_in[0];
    psi_out[3] = -psi_in[1];
}

// ============================================================================
// Spatial Derivatives and Hamiltonian
// ============================================================================

/**
 * @brief Load spinor into shared memory with periodic boundaries
 */
void load_shared_memory(uvec2 global_id, uvec2 local_id) {
    uint gx = global_id.x;
    uint gy = global_id.y;
    uint lx = local_id.x;
    uint ly = local_id.y;

    // Load center tile (all 4 spinor components)
    if (gx < params.Nx && gy < params.Ny) {
        uint idx = gy * params.Nx + gx;
        for (int comp = 0; comp < 4; comp++) {
            s_psi[ly + 1][lx + 1][comp] = psi[idx * 4 + comp];
        }
    }

    // Load borders (periodic boundaries)
    // Left border
    if (lx == 0 && gy < params.Ny) {
        uint border_x = (gx == 0) ? (params.Nx - 1) : (gx - 1);
        uint idx = gy * params.Nx + border_x;
        for (int comp = 0; comp < 4; comp++) {
            s_psi[ly + 1][0][comp] = psi[idx * 4 + comp];
        }
    }

    // Right border
    if (lx == 15 && gy < params.Ny) {
        uint border_x = (gx == params.Nx - 1) ? 0 : (gx + 1);
        uint idx = gy * params.Nx + border_x;
        for (int comp = 0; comp < 4; comp++) {
            s_psi[ly + 1][17][comp] = psi[idx * 4 + comp];
        }
    }

    // Top border
    if (ly == 0 && gx < params.Nx) {
        uint border_y = (gy == 0) ? (params.Ny - 1) : (gy - 1);
        uint idx = border_y * params.Nx + gx;
        for (int comp = 0; comp < 4; comp++) {
            s_psi[0][lx + 1][comp] = psi[idx * 4 + comp];
        }
    }

    // Bottom border
    if (ly == 15 && gx < params.Nx) {
        uint border_y = (gy == params.Ny - 1) ? 0 : (gy + 1);
        uint idx = border_y * params.Nx + gx;
        for (int comp = 0; comp < 4; comp++) {
            s_psi[17][lx + 1][comp] = psi[idx * 4 + comp];
        }
    }

    barrier();
}

/**
 * @brief Compute spatial derivatives using centered finite differences
 */
void compute_spatial_derivatives(uint local_x, uint local_y,
                                 out vec2 dpsi_dx[4], out vec2 dpsi_dy[4]) {
    const float dx = 1.0;  // Grid spacing (normalized)

    for (int i = 0; i < 4; i++) {
        vec2 psi_xp = s_psi[local_y + 1][local_x + 2][i];  // x+1
        vec2 psi_xm = s_psi[local_y + 1][local_x][i];      // x-1
        vec2 psi_yp = s_psi[local_y + 2][local_x + 1][i];  // y+1
        vec2 psi_ym = s_psi[local_y][local_x + 1][i];      // y-1

        dpsi_dx[i] = (psi_xp - psi_xm) / (2.0 * dx);
        dpsi_dy[i] = (psi_yp - psi_ym) / (2.0 * dx);
    }
}

/**
 * @brief Compute Hamiltonian action (deterministic part)
 * H = -i·(α^x·∂_x + α^y·∂_y) + β·M
 * where M = Δ·R(x) is the mass from synchronization
 */
void apply_hamiltonian(vec2 psi_current[4], vec2 dpsi_dx[4], vec2 dpsi_dy[4],
                       float R, out vec2 H_psi[4]) {
    // Kinetic term: -i·(α^x·∂_x + α^y·∂_y)
    vec2 alpha_x_dpsi_dx[4];
    apply_alpha_x(dpsi_dx, alpha_x_dpsi_dx);

    vec2 alpha_y_dpsi_dy[4];
    apply_alpha_y(dpsi_dy, alpha_y_dpsi_dy);

    vec2 kinetic[4];
    for (int i = 0; i < 4; i++) {
        vec2 sum = alpha_x_dpsi_dx[i] + alpha_y_dpsi_dy[i];
        kinetic[i] = cmul(vec2(0, -1), sum);  // -i·(...)
    }

    // Mass term: β·M·Ψ where M = Δ·R
    float mass = params.Delta * R;

    vec2 beta_psi[4];
    apply_beta(psi_current, beta_psi);

    // Total: H·Ψ = kinetic + mass·β·Ψ
    for (int i = 0; i < 4; i++) {
        H_psi[i] = kinetic[i] + mass * beta_psi[i];
    }
}

// ============================================================================
// Main Compute Shader
// ============================================================================

void main() {
    uvec2 global_id = gl_GlobalInvocationID.xy;
    uvec2 local_id = gl_LocalInvocationID.xy;

    // Bounds check
    if (global_id.x >= params.Nx || global_id.y >= params.Ny) {
        return;
    }

    uint idx = global_id.y * params.Nx + global_id.x;

    // Initialize PRNG with unique seed per thread and timestep
    uint seed = global_id.x + global_id.y * 65536u + params.time_step * 16777216u;
    pcg_init(seed);

    // Load spinor into shared memory
    load_shared_memory(global_id, local_id);

    // Get current spinor
    vec2 psi_current[4];
    for (int i = 0; i < 4; i++) {
        psi_current[i] = psi[idx * 4 + i];
    }

    // Get synchronization field R(x)
    float R = R_field[idx];

    // Compute spatial derivatives
    vec2 dpsi_dx[4], dpsi_dy[4];
    compute_spatial_derivatives(local_id.x, local_id.y, dpsi_dx, dpsi_dy);

    // Compute deterministic Hamiltonian evolution
    vec2 H_psi[4];
    apply_hamiltonian(psi_current, dpsi_dx, dpsi_dy, R, H_psi);

    // Euler-Maruyama integration
    // dΨ/dt = -i·H·Ψ (deterministic) + σ_Ψ·ξ (stochastic)

    vec2 psi_new[4];

    // Deterministic update: Ψ + dt·(-i·H·Ψ)
    for (int i = 0; i < 4; i++) {
        vec2 drift = cmul(vec2(0, -1), H_psi[i]);  // -i·H·Ψ
        psi_new[i] = psi_current[i] + params.dt * drift;
    }

    // Stochastic term: σ_Ψ·√(dt)·ξ(t)
    // Each spinor component gets independent complex noise
    float noise_amplitude = params.sigma_psi * sqrt(params.dt);

    for (int i = 0; i < 4; i++) {
        vec2 noise = noise_amplitude * complex_randn();
        psi_new[i] += noise;
    }

    // Optional: Normalize to conserve probability (soft normalization)
    // This helps stability but is not strictly necessary
    float norm_sq = 0.0;
    for (int i = 0; i < 4; i++) {
        norm_sq += dot(psi_new[i], psi_new[i]);
    }

    if (norm_sq > 0.001) {
        float norm_factor = 1.0 / sqrt(sqrt(norm_sq));  // Soft normalization
        // Full normalization would be: 1.0 / sqrt(norm_sq)
        // We use soft normalization to avoid sudden jumps
        for (int i = 0; i < 4; i++) {
            psi_new[i] = mix(psi_new[i], psi_new[i] * norm_factor, 0.1);
        }
    }

    // Write output
    for (int i = 0; i < 4; i++) {
        psi[idx * 4 + i] = psi_new[i];
    }
}